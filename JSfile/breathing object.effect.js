// breathing object.effect.js

export const breathing objectEffect = {
  id: "breathing object",
  name: "Breathing object",
  
  description: `## üíì EFFET 41 : BREATHING OBJECT

**CAT√âGORIE :** IMAGE  
**EFFET DEMAND√â :** Breathing_Object  
**ID UNIQUE :** organic-life-respiration-041  
**NOM AFFICHAGE :** Respiration Organique Vivante  

**DESCRIPTION :** Image respire comme un organisme vivant avec expansion/contraction naturelle. Rythme respiratoire authentique (4s inspiration, 6s expiration), micro-d√©formations organiques suivant les contours, pulsation chromatique synchronis√©e. L'image semble dot√©e d'une conscience respiratoire.

**SP√âCIFICATIONS ADDICTION :**
- Rythme respiratoire avec variations naturelles (stress, calme)
- Micro-d√©formations r√©v√©lant la "physiologie" de l'image
- Pulsation chromatique cr√©ant un effet de circulation sanguine
- Pauses respiratoires cr√©ant des moments de tension dramatique

--------------------------------------------------------------------------

üíì BREATHING OBJECT EFFECT CR√â√â !
‚ú® SYST√àME RESPIRATOIRE PHYSIOLOGIQUE AUTHENTIQUE :
ü´Å CYCLE RESPIRATOIRE R√âALISTE :

Inspiration (4s) : Expansion progressive avec easing naturel
Expiration (6s) : Contraction douce et r√©guli√®re
Pauses dramatiques : Apn√©es cr√©ant tension et suspense
Variabilit√© naturelle : Adaptations selon le stress

‚ù§Ô∏è SYST√àME CARDIOVASCULAIRE INT√âGR√â :

Fr√©quence cardiaque : 72-100 BPM selon le stress
Pulsation chromatique : Circulation sanguine visible
Oxyg√©nation dynamique : Couleurs √©voluant avec la respiration
Micro-pulsations : Battements cardiaques subtils

üß† INTELLIGENCE PHYSIOLOGIQUE :

Niveau de stress adaptatif : Influence rythme et amplitude
M√©moire des cycles : Apprentissage et adaptation
R√©actions organiques : √âv√©nements de stress al√©atoires
Tension musculaire : D√©formations selon l'√©tat √©motionnel

üåä D√âFORMATIONS ORGANIQUES COMPLEXES :

16 points de contr√¥le : D√©formation naturelle des contours
Micro-vibrations : 8 sources de tremblements organiques
Variations de phase : Chaque point suit son propre rythme
Influence cardiaque : Pulsations rapides superpos√©es

üé≠ CARACT√âRISTIQUES ADDICTIVES INT√âGR√âES :
üîÑ Impr√©visibilit√© Contr√¥l√©e (30%) :

Pauses respiratoires : Apn√©es dramatiques impr√©visibles
Variations de stress : Changements √©motionnels al√©atoires
Micro-√©v√©nements : Tremblements et pulsations spontan√©s
Adaptation rythmique : √âvolution bas√©e sur l'historique

üíé R√©v√©lations Progressives :

Phases distinctes : Inspiration/expiration/pause avec indicateurs subtils
Circulation visible : Oxyg√©nation r√©v√©lant la "physiologie"
Tension croissante : Build-up vers les pauses dramatiques
Micro-d√©tails : Pulsations de surface r√©compensant l'attention

‚ö° Performance Optimis√©e :

Calculs incr√©mentaux : Mise √† jour progressive des d√©formations
Rendu conditionnel : Skip des effets selon les seuils
Canvas s√©par√©s : Optimisation des effets complexes
M√©moire limit√©e : Historique des cycles plafonn√© √† 10

üéÆ PARAM√àTRES PHYSIOLOGIQUES :

Vitesse : M√©tabolisme g√©n√©ral (ralenti/acc√©l√©r√©)
Intensit√© : Visibilit√© des effets physiologiques
Amplitude : Profondeur de la respiration
Rythme : Fr√©quence respiratoire de base
Circulation : Intensit√© des effets cardiovasculaires
Stress : Niveau de tension √©motionnelle

üß¨ D√âTAILS PHYSIOLOGIQUES AUTHENTIQUES :

Inspiration : Plus rapide au d√©but (r√©flexe)
Expiration : Douce et contr√¥l√©e (muscles lisses)
Corr√©lation cardio-respiratoire : Synchronisation naturelle
R√©ponse au stress : Acc√©l√©ration et irr√©gularit√©s r√©alistes
Oxyg√©nation : Changement de couleur sang veineux/art√©riel
Cet effet transforme n'importe quel √©l√©ment en organisme vivant respirant avec une physiologie compl√®te et authentique !
üî¨ ASPECTS SCIENTIFIQUES IMPL√âMENT√âS :
ü©∫ Physiologie Respiratoire R√©elle :

Compliance pulmonaire : R√©sistance variable selon la phase
Volume courant : Variations naturelles (500ml ¬±20%)
Fr√©quence de base : 12-20 respirations/minute
R√©serve inspiratoire : Capacit√© d'expansion suppl√©mentaire

ü´Ä Couplage Cardio-Respiratoire :

Arythmie sinusale : Acc√©l√©ration cardiaque √† l'inspiration
Retour veineux : Influence de la pression thoracique
Baror√©flexe : Adaptation tension art√©rielle
Variabilit√© HRV : Indicateur d'√©tat autonome

üß™ Chimie Sanguine Visuelle :

Saturation O2 : Rouge vif (art√©riel) vs rouge sombre (veineux)
pH sanguin : Influence sur la couleur et l'intensit√©
CO2 dissous : Drive respiratoire via chimior√©cepteurs
H√©moglobine : Transport d'oxyg√®ne visualis√©

üé® RENDU VISUEL SOPHISTIQU√â :
üåà Palette Chromatique Physiologique :
// Sang d√©soxyg√©n√© (veineux)
teinteSanguine: { r: 220, g: 100, b: 100 }

// Sang oxyg√©n√© (art√©riel)  
teinteOxygenee: { r: 255, g: 160, b: 160 }

// Interpolation dynamique selon respiration

üé≠ Effets Visuels Multicouches :

Couche circulation : Gradient radial pulsant
Couche d√©formation : Mesh organique adaptatif
Couche micro-d√©tails : Pulsations de surface
Couche indication : Halo subtil de phase

‚öôÔ∏è Algorithmes Bio-Inspir√©s :

R√©seaux de d√©formation : Simulation tissu musculaire
Oscillateurs coupl√©s : Synchronisation cardio-respiratoire
Bruit organique : Variations naturelles via Perlin noise
Adaptation hom√©ostatique : Retour √† l'√©quilibre

üß† INTELLIGENCE COMPORTEMENTALE :
üìö Apprentissage Adaptatif :

// Historique des 10 derniers cycles
historiqueCycles: [
  { duree: 4200, profondeur: 0.8, stress: 0.3 },
  { duree: 3800, profondeur: 0.9, stress: 0.4 },
  // ... analyse pour adaptation
]

üéØ R√©ponses √âmotionnelles :

Stress aigu : Respiration courte et rapide
Relaxation : Respiration profonde et lente
Tension : Irr√©gularit√©s et micro-blocages
S√©r√©nit√© : Rythme stable et harmonieux

üîÆ EXP√âRIENCE UTILISATEUR HYPNOTIQUE :
üí´ Synchronisation Inconsciente :
L'utilisateur tend naturellement √† synchroniser sa propre respiration avec l'objet, cr√©ant un √©tat de m√©ditation involontaire.
üåÄ Captation Attentionnelle :

Pauses impr√©visibles ‚Üí tension dramatique
Micro-d√©tails √©volutifs ‚Üí r√©compense de l'observation
Rythme organique ‚Üí effet apaisant et addictif
Variations subtiles ‚Üí maintien de l'int√©r√™t

üßò Effet Th√©rapeutique :
Peut induire un √©tat de calme et de concentration par mim√©tisme respiratoire, transformant le GIF en outil de relaxation active.
üöÄ APPLICATIONS CR√âATIVES :
üì± Marketing Wellness :

Applications de m√©ditation
Produits de relaxation
Contenus th√©rapeutiques
Branding organique/naturel

üé¨ Storytelling √âmotionnel :

Personnages "vivants"
Ambiances organiques
Tension narrative via respiration
Empathie visuelle renforc√©e

Cet effet r√©volutionne la perception des objets num√©riques en leur donnant une √¢me respiratoire authentique qui cr√©e une connexion √©motionnelle profonde avec l'observateur ! üíì‚ú®`,

  category: "image",
  subcategory: "style",
  intensity: "low",
  performance: "light",

  compatibility: {
    text: false,
    image: true,
    logo: false,
    background: true
  },

  tags: ["image", "breathing", "phase", "breathing object"],

  parameters: {
    // Param√®tres par d√©faut - √† personnaliser selon l'effet
    vitesse: {
      type: "range",
      min: 0.1,
      max: 3,
      default: 1,
      description: "Vitesse d'animation"
    },
    intensite: {
      type: "range",
      min: 0,
      max: 1,
      default: 0.8,
      description: "Intensit√© de l'effet"
    }
  },

  preview: {
    gif: "breathing object.gif",
    duration: 3000,
    loop: true
  },

  engine: (element, params) => {
    
    // Code original de l'effet int√©gr√©
    constructor(config = {}) {
        super({
            id: 'organic-life-respiration-041',
            name: 'Respiration Organique Vivante',
            category: 'image',
            version: '1.0',
            performance: 'low',
            parameters: {
                vitesse: { type: 'range', min: 0.1, max: 3, default: 1 },
                intensite: { type: 'range', min: 0, max: 1, default: 0.6 },
                amplitude: { type: 'range', min: 0.05, max: 0.3, default: 0.15 },
                rythme: { type: 'range', min: 0.5, max: 2, default: 1 },
                circulation: { type: 'range', min: 0, max: 1, default: 0.7 },
                stress: { type: 'range', min: 0, max: 1, default: 0.3 }
            }
        });

        // Syst√®me de respiration physiologique
        this.temps = 0;
        this.phaseRespiration = 'inspiration'; // inspiration, expiration, pause
        this.cycleRespiration = 0; // Position dans le cycle (0-1)
        this.dureeInspiration = 4000; // 4 secondes
        this.dureeExpiration = 6000;  // 6 secondes
        this.dureePause = 1000;       // 1 seconde de pause
        
        // Variables physiologiques
        this.frequenceCardiaque = 72; // BPM
        this.variabilite = 0;         // Variabilit√© du rythme
        this.niveauStress = 0.3;      // Niveau de stress actuel
        this.profondeurRespiration = 1; // Profondeur de la respiration
        
        // Syst√®me de d√©formation organique
        this.pointsDeformation = [];
        this.nombrePoints = 16; // Points de contr√¥le pour d√©formation
        this.rayonInfluence = 100;
        
        // Pulsation chromatique et circulation
        this.pulsationChromatique = 0;
        this.intensiteCouleur = 0;
        this.teinteSanguine = { r: 220, g: 100, b: 100 };
        this.teinteOxygenee = { r: 255, g: 160, b: 160 };
        
        // Canvas pour effets complexes
        this.canvasDeformation = null;
        this.ctxDeformation = null;
        this.canvasCirculation = null;
        this.ctxCirculation = null;
        
        // Micro-variations organiques
        this.microVibrations = [];
        this.tensionMusculaire = 0;
        
        // Syst√®me de pauses dramatiques
        this.pauseActive = false;
        this.prochainePause = 15000; // Premi√®re pause dans 15s
        this.dureePauseActuelle = 0;
        
        // M√©moire des cycles pr√©c√©dents pour adaptation
        this.historiqueCycles = [];
        this.adaptationRythme = 0;
    }

    initialize(canvas, element) {
        // Canvas pour d√©formations organiques
        this.canvasDeformation = document.createElement('canvas');
        this.canvasDeformation.width = canvas.width;
        this.canvasDeformation.height = canvas.height;
        this.ctxDeformation = this.canvasDeformation.getContext('2d');
        
        // Canvas pour circulation sanguine
        this.canvasCirculation = document.createElement('canvas');
        this.canvasCirculation.width = canvas.width;
        this.canvasCirculation.height = canvas.height;
        this.ctxCirculation = this.canvasCirculation.getContext('2d');
        
        // Initialisation des points de d√©formation
        this.initPointsDeformation(element);
        
        // Initialisation des micro-vibrations
        this.initMicroVibrations();
        
        // Ajustement du rythme selon l'√©l√©ment
        this.ajusterRythmeInitial(element);
    }

    initPointsDeformation(element) {
        this.pointsDeformation = [];
        const centreX = element.x + element.width / 2;
        const centreY = element.y + element.height / 2;
        
        for (let i = 0; i < this.nombrePoints; i++) {
            const angle = (i / this.nombrePoints) * Math.PI * 2;
            const rayon = Math.max(element.width, element.height) * 0.6;
            
            this.pointsDeformation.push({
                x: centreX + Math.cos(angle) * rayon,
                y: centreY + Math.sin(angle) * rayon,
                angle: angle,
                rayonBase: rayon,
                intensite: 0.5 + Math.random() * 0.5,
                phase: Math.random() * Math.PI * 2,
                vitessePhase: 0.8 + Math.random() * 0.4
            });
        }
    }

    initMicroVibrations() {
        this.microVibrations = [];
        for (let i = 0; i < 8; i++) {
            this.microVibrations.push({
                amplitude: 0.5 + Math.random() * 1.5,
                frequence: 0.02 + Math.random() * 0.08,
                phase: Math.random() * Math.PI * 2,
                actif: true
            });
        }
    }

    ajusterRythmeInitial(element) {
        // Ajustement du rythme selon la taille (plus grand = plus lent)
        const taille = Math.sqrt(element.width * element.height);
        const facteurTaille = Math.max(0.7, Math.min(1.3, taille / 200));
        
        this.dureeInspiration *= facteurTaille;
        this.dureeExpiration *= facteurTaille;
        this.dureePause *= facteurTaille;
    }

    // Noise organique pour variations
    noise(x, y = 0, z = 0) {
        const n = Math.sin(x * 12.9898 + y * 78.233 + z * 37.719) * 43758.5453;
        return (n - Math.floor(n));
    }

    // Fonction d'easing pour respiration naturelle
    easingRespiration(t, type) {
        switch(type) {
            case 'inspiration':
                // Inspiration plus rapide au d√©but, ralentit
                return 1 - Math.pow(1 - t, 3);
            case 'expiration':
                // Expiration douce et r√©guli√®re
                return Math.sin(t * Math.PI * 0.5);
            case 'pause':
                // Plateau stable avec micro-variations
                return 1 + Math.sin(t * Math.PI * 4) * 0.02;
            default:
                return t;
        }
    }

    update(deltaTime) {
        this.temps += deltaTime * this.parameters.vitesse.value;
        
        // Mise √† jour du niveau de stress
        this.updateNiveauStress(deltaTime);
        
        // Mise √† jour du cycle respiratoire
        this.updateCycleRespiration(deltaTime);
        
        // Mise √† jour des d√©formations organiques
        this.updateDeformationsOrganiques(deltaTime);
        
        // Mise √† jour de la circulation chromatique
        this.updateCirculationChromatique(deltaTime);
        
        // Mise √† jour des micro-vibrations
        this.updateMicroVibrations(deltaTime);
        
        // Gestion des pauses dramatiques
        this.updatePausesDramatiques(deltaTime);
        
        // Adaptation du rythme bas√©e sur l'historique
        this.updateAdaptationRythme();
    }

    updateNiveauStress(deltaTime) {
        // √âvolution du stress avec variations organiques
        const stressBase = this.parameters.stress.value;
        const variationStress = Math.sin(this.temps * 0.0003) * 0.2;
        
        // √âv√©nements de stress al√©atoires
        if (Math.random() < 0.0001 * deltaTime) {
            this.niveauStress += (Math.random() - 0.5) * 0.3;
        }
        
        // Retour progressif vers le niveau de base
        const targetStress = stressBase + variationStress;
        this.niveauStress += (targetStress - this.niveauStress) * deltaTime * 0.001;
        this.niveauStress = Math.max(0, Math.min(1, this.niveauStress));
        
        // Ajustement des dur√©es selon le stress
        const facteurStress = 1 + this.niveauStress * 0.5;
        this.frequenceCardiaque = 72 + this.niveauStress * 28; // 72-100 BPM
    }

    updateCycleRespiration(deltaTime) {
        const facteurRythme = this.parameters.rythme.value;
        const deltaAjuste = deltaTime * facteurRythme;
        
        // Ajustement des dur√©es selon le stress
        const facteurStress = 1 - this.niveauStress * 0.3;
        const inspirationAjustee = this.dureeInspiration * facteurStress;
        const expirationAjustee = this.dureeExpiration * facteurStress;
        
        if (this.pauseActive) {
            this.dureePauseActuelle += deltaAjuste;
            this.cycleRespiration = 1; // Maintenir position haute
            
            if (this.dureePauseActuelle >= this.dureePause * (2 + this.niveauStress)) {
                this.pauseActive = false;
                this.dureePauseActuelle = 0;
                this.phaseRespiration = 'expiration';
                this.cycleRespiration = 0;
                
                // Programmer la prochaine pause
                this.prochainePause = this.temps + 20000 + Math.random() * 15000;
            }
            return;
        }
        
        if (this.phaseRespiration === 'inspiration') {
            this.cycleRespiration += deltaAjuste / inspirationAjustee;
            
            if (this.cycleRespiration >= 1) {
                this.cycleRespiration = 1;
                this.phaseRespiration = 'expiration';
                
                // Enregistrer le cycle pour adaptation
                this.historiqueCycles.push({
                    duree: inspirationAjustee,
                    profondeur: this.profondeurRespiration,
                    stress: this.niveauStress
                });
                
                if (this.historiqueCycles.length > 10) {
                    this.historiqueCycles.shift();
                }
            }
        } else if (this.phaseRespiration === 'expiration') {
            this.cycleRespiration -= deltaAjuste / expirationAjustee;
            
            if (this.cycleRespiration <= 0) {
                this.cycleRespiration = 0;
                this.phaseRespiration = 'inspiration';
            }
        }
        
        // Calcul de la profondeur avec easing naturel
        const easedCycle = this.easingRespiration(this.cycleRespiration, this.phaseRespiration);
        this.profondeurRespiration = easedCycle * this.parameters.amplitude.value;
        
        // Ajout de variabilit√© naturelle
        const variabilite = this.noise(this.temps * 0.001) * 0.1;
        this.profondeurRespiration += variabilite * this.parameters.amplitude.value;
    }

    updateDeformationsOrganiques(deltaTime) {
        this.pointsDeformation.forEach(point => {
            // Mise √† jour de la phase individuelle
            point.phase += deltaTime * point.vitessePhase * 0.001;
            
            // D√©formation bas√©e sur la respiration
            const deformationRespiration = this.profondeurRespiration * point.intensite;
            
            // D√©formation cardiaque (plus rapide)
            const pulsationCardiaque = Math.sin(this.temps * 0.001 * this.frequenceCardiaque / 60 * Math.PI * 2);
            const deformationCardiaque = pulsationCardiaque * 0.05 * this.parameters.circulation.value;
            
            // D√©formation organique complexe
            const deformationOrganique = Math.sin(point.phase) * 0.02;
            
            // D√©formation totale
            const deformationTotale = deformationRespiration + deformationCardiaque + deformationOrganique;
            
            // Application de la tension musculaire
            this.tensionMusculaire = this.niveauStress * 0.1;
            const facteurTension = 1 + this.tensionMusculaire;
            
            point.rayonActuel = point.rayonBase * (1 + deformationTotale * facteurTension);
        });
    }

    updateCirculationChromatique(deltaTime) {
        // Pulsation synchronis√©e avec le rythme cardiaque
        const pulsationCardiaque = Math.sin(this.temps * 0.001 * this.frequenceCardiaque / 60 * Math.PI * 2);
        this.pulsationChromatique = (pulsationCardiaque + 1) * 0.5; // 0-1
        
        // Intensit√© bas√©e sur la respiration (oxyg√©nation)
        const oxygenation = this.profondeurRespiration * 0.7 + 0.3;
        this.intensiteCouleur = oxygenation * this.parameters.circulation.value;
        
        // Interpolation entre teintes selon l'oxyg√©nation
        const facteurOxygene = Math.max(0, Math.min(1, oxygenation));
        this.teinteCourante = {
            r: this.teinteSanguine.r + (this.teinteOxygenee.r - this.teinteSanguine.r) * facteurOxygene,
            g: this.teinteSanguine.g + (this.teinteOxygenee.g - this.teinteSanguine.g) * facteurOxygene,
            b: this.teinteSanguine.b + (this.teinteOxygenee.b - this.teinteSanguine.b) * facteurOxygene
        };
    }

    updateMicroVibrations(deltaTime) {
        this.microVibrations.forEach(vibration => {
            vibration.phase += deltaTime * vibration.frequence;
            
            // Modulation par le stress
            vibration.amplitudeActuelle = vibration.amplitude * (1 + this.niveauStress * 2);
            
            // D√©sactivation al√©atoire pour effet naturel
            if (Math.random() < 0.001 * deltaTime) {
                vibration.actif = !vibration.actif;
            }
        });
    }

    updatePausesDramatiques(deltaTime) {
        // V√©rification si c'est le moment d'une pause
        if (!this.pauseActive && this.temps >= this.prochainePause) {
            // Conditions pour d√©clencher une pause
            const probabilitePause = 0.3 + this.niveauStress * 0.4;
            
            if (Math.random() < probabilitePause && this.phaseRespiration === 'inspiration' && this.cycleRespiration > 0.8) {
                this.pauseActive = true;
                this.dureePauseActuelle = 0;
                this.phaseRespiration = 'pause';
            } else {
                // Reporter la pause
                this.prochainePause = this.temps + 5000 + Math.random() * 10000;
            }
        }
    }

    updateAdaptationRythme() {
        if (this.historiqueCycles.length < 3) return;
        
        // Analyse de l'historique pour adaptation
        const moyenneStress = this.historiqueCycles.reduce((sum, cycle) => sum + cycle.stress, 0) / this.historiqueCycles.length;
        
        // Adaptation progressive du rythme
        this.adaptationRythme = moyenneStress * 0.2;
    }

    render(ctx, element, deltaTime) {
        const { width, height } = ctx.canvas;
        
        ctx.save();
        
        // Nettoyage des canvas temporaires
        this.ctxDeformation.clearRect(0, 0, width, height);
        this.ctxCirculation.clearRect(0, 0, width, height);
        
        // Calcul des transformations de respiration
        const scaleRespiration = 1 + this.profondeurRespiration;
        const centreX = element.x + element.width / 2;
        const centreY = element.y + element.height / 2;
        
        // Application des micro-vibrations
        let offsetX = 0, offsetY = 0;
        this.microVibrations.forEach(vibration => {
            if (!vibration.actif) return;
            offsetX += Math.sin(vibration.phase) * vibration.amplitudeActuelle;
            offsetY += Math.cos(vibration.phase * 1.3) * vibration.amplitudeActuelle;
        });
        
        // Rendu de l'effet de circulation sanguine
        this.renderCirculationSanguine(ctx, element, centreX, centreY);
        
        // Rendu de l'√©l√©ment avec d√©formations organiques
        this.renderElementAvecDeformations(ctx, element, scaleRespiration, offsetX, offsetY);
        
        // Rendu des effets de surface (micro-pulsations)
        this.renderEffetsSurface(ctx, element, centreX, centreY);
        
        // Indication visuelle de la phase respiratoire (subtile)
        this.renderIndicationPhase(ctx, centreX, centreY);
        
        ctx.restore();
    }

    renderCirculationSanguine(ctx, element, centreX, centreY) {
        if (this.parameters.circulation.value < 0.1) return;
        
        ctx.save();
        
        // Effet de circulation avec pulsation
        const intensiteCirculation = this.intensiteCouleur * this.pulsationChromatique;
        
        if (intensiteCirculation > 0.05) {
            // D√©grad√© radial pulsant
            const rayonCirculation = Math.max(element.width, element.height) * 0.7;
            const gradient = ctx.createRadialGradient(
                centreX, centreY, 0,
                centreX, centreY, rayonCirculation
            );
            
            const alpha = intensiteCirculation * 0.15;
            const couleur = this.teinteCourante;
            
            gradient.addColorStop(0, `rgba(${couleur.r}, ${couleur.g}, ${couleur.b}, ${alpha})`);
            gradient.addColorStop(0.6, `rgba(${couleur.r}, ${couleur.g}, ${couleur.b}, ${alpha * 0.5})`);
            gradient.addColorStop(1, `rgba(${couleur.r}, ${couleur.g}, ${couleur.b}, 0)`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centreX, centreY, rayonCirculation, 0, Math.PI * 2);
            ctx.fill();
            
            // Pulsations de surface
            for (let i = 0; i < 3; i++) {
                const rayonPulsation = rayonCirculation * (0.3 + i * 0.2) * (1 + this.pulsationChromatique * 0.1);
                const alphaPulsation = alpha * (1 - i * 0.3) * this.pulsationChromatique;
                
                if (alphaPulsation > 0.02) {
                    ctx.strokeStyle = `rgba(${couleur.r}, ${couleur.g}, ${couleur.b}, ${alphaPulsation})`;
                    ctx.lineWidth = 1 + i;
                    ctx.beginPath();
                    ctx.arc(centreX, centreY, rayonPulsation, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }
        
        ctx.restore();
    }

    renderElementAvecDeformations(ctx, element, scaleRespiration, offsetX, offsetY) {
        ctx.save();
        
        // Translation vers le centre avec micro-vibrations
        ctx.translate(
            element.x + element.width / 2 + offsetX,
            element.y + element.height / 2 + offsetY
        );
        
        // Rotation de base
        ctx.rotate(element.rotation);
        
        // √âchelle de respiration avec d√©formations organiques
        const scaleX = scaleRespiration;
        const scaleY = scaleRespiration * (1 + Math.sin(this.temps * 0.002) * 0.02);
        ctx.scale(scaleX, scaleY);
        
        // Application de l'opacit√© avec variations physiologiques
        const opaciteBase = element.opacity;
        const variationOpacite = Math.sin(this.frequenceCardiaque / 60 * this.temps * 0.001 * Math.PI * 2) * 0.05;
        ctx.globalAlpha = opaciteBase * (1 + variationOpacite * this.parameters.circulation.value);
        
        // Rendu du contenu
        if (element.content) {
            if (typeof element.content === 'string') {
                // Effet de "souffle" sur le texte
                const souffleIntensity = this.profondeurRespiration * 0.1;
                ctx.shadowColor = `rgba(255, 255, 255, ${souffleIntensity})`;
                ctx.shadowBlur = 10 * souffleIntensity;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(element.content, 0, 0);
            }
        }
        
        ctx.restore();
    }

    renderEffetsSurface(ctx, element, centreX, centreY) {
        if (this.parameters.intensite.value < 0.3) return;
        
        ctx.save();
        
        // Micro-pulsations de surface
        const nombrePulsations = Math.floor(4 + this.niveauStress * 6);
        
        for (let i = 0; i < nombrePulsations; i++) {
            const angle = (i / nombrePulsations) * Math.PI * 2 + this.temps * 0.001;
            const rayon = Math.max(element.width, element.height) * (0.3 + Math.random() * 0.4);
            
            const x = centreX + Math.cos(angle) * rayon;
            const y = centreY + Math.sin(angle) * rayon;
            
            const pulsation = Math.sin(this.temps * 0.003 + i) * 0.5 + 0.5;
            const alpha = pulsation * this.parameters.intensite.value * 0.1;
            
            if (alpha > 0.02) {
                const gradientMicro = ctx.createRadialGradient(x, y, 0, x, y, 15);
                gradientMicro.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                gradientMicro.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradientMicro;
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        ctx.restore();
    }

    renderIndicationPhase(ctx, centreX, centreY) {
        if (this.parameters.intensite.value < 0.7) return;
        
        ctx.save();
        
        // Indication subtile de la phase respiratoire
        let couleurPhase, intensitePhase;
        
        switch(this.phaseRespiration) {
            case 'inspiration':
                couleurPhase = 'rgba(100, 200, 255, ';
                intensitePhase = this.cycleRespiration * 0.1;
                break;
            case 'expiration':
                couleurPhase = 'rgba(255, 150, 100, ';
                intensitePhase = (1 - this.cycleRespiration) * 0.1;
                break;
            case 'pause':
                couleurPhase = 'rgba(255, 255, 100, ';
                intensitePhase = (Math.sin(this.temps * 0.01) * 0.5 + 0.5) * 0.15;
                break;
            default:
                intensitePhase = 0;
        }
        
        if (intensitePhase > 0.02) {
            // Halo tr√®s subtil indiquant la phase
            const rayonPhase = Math.max(element.width, element.height) * 1.2;
            const gradientPhase = ctx.createRadialGradient(
                centreX, centreY, rayonPhase * 0.8,
                centreX, centreY, rayonPhase
            );
            
            gradientPhase.addColorStop(0, couleurPhase + '0)');
            gradientPhase.addColorStop(1, couleurPhase + intensitePhase + ')');
            
            ctx.fillStyle = gradientPhase;
            ctx.beginPath();
            ctx.arc(centreX, centreY, rayonPhase, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }

    destroy() {
        this.pointsDeformation = [];
        this.microVibrations = [];
        this.historiqueCycles = [];
        
        if (this.canvasDeformation) {
            this.canvasDeformation = null;
            this.ctxDeformation = null;
        }
        
        if (this.canvasCirculation) {
            this.canvasCirculation = null;
            this.ctxCirculation = null;
        }
    }
    
  }
};
